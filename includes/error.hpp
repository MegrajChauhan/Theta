#ifndef _ERROR_
#define _ERROR_

#include "tokens.hpp"
#include <vector>
#include <algorithm>
#include <unordered_map>
#include <stack>
#include <iostream>

namespace theta
{
    namespace error
    {
        enum error_t
        {
            _FILE_INVALID,
            _FILE_A_DIR,
            _FILE_NOT_AVAI,
            _IMPORT_PATH_NOT_SPECIFIED,
            _IMPORT_PATH_INVALID,
        };

        struct Error
        {
            tokens::token_loc loc;
            std::string msg;
            std::string err_line;
            error_t type;
        };

        static std::vector<Error> errors;
        static std::vector<std::string> files;
        // the key here will be the file that was included by the file in the value
        static std::unordered_map<size_t, size_t> include_tree;
        static size_t count = -1;

        void register_new_file(std::string);

        void register_new_error(std::string, std::string, tokens::token_loc, error_t);

        bool is_file_already_registered(std::string);

        void add_to_tree(size_t, size_t);

        std::vector<Error> get_errors();
        std::vector<std::string> get_files();
        size_t get_count();
        std::unordered_map<size_t, size_t> get_inc_tree();

        // after every step, this function is called
        // if any fatal error is encountered, the compilation will not move to the next step
        void _clear_all_errors_();

        // based on ind, error message is generated by showing the include depth
        std::stack<size_t> gen_error_info(size_t ind);

        // what this does is basically read the given line from the file
        std::string get_line_from_file(size_t ind, size_t line);

        void print_error(size_t line, size_t colst, size_t colend, std::string file, std::string errmsg, std::stack<size_t> filetree, std::string errline);
    };
};

#endif